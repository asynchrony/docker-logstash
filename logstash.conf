input {
  tcp {
    type  => "systemd"
    port  => 5001
    codec => json_lines
  }
  udp {
    type => "fite-logs"
    port => 5010
    codec => multiline {
                # Grok pattern names are valid! :)
                pattern => "^%{TIMESTAMP_ISO8601} "
                negate => true
                what => previous
             }
  }
  udp {
    type => "fite-iis-logs"
    port => 5011
    codec => json {
               charset => "CP1252"
             }
  }
  udp {
    type => "fite-webapps-logs"
    port => 5012
    codec => multiline {
                # Grok pattern names are valid! :)
                pattern => "^%{TIMESTAMP_ISO8601} "
                negate => true
                what => previous
             }
  }
}

filter {
  if [type] == "fite-iis-logs" {
      date {
        match => [ "EventTime", "yyyy-MM-dd HH:mm:ss" ]
        target => "@timestamp"
      }
    mutate {
      remove_field => ["EventTime"]
    }
  }
  if [type] == "fite-webapps-logs" {
    grok{
      match => ["message","%{TIMESTAMP_ISO8601:ErrorTime} \[%{POSINT}\] %{LOGLEVEL} %{GREEDYDATA:module} - %{GREEDYDATA:exception}"]
    }
    date {
        match => [ "ErrorTime", "yyyy-MM-dd HH:mm:ss.SSS" ]
        target => "@timestamp"
    }    
  }  
  if [type] == "systemd" {
    mutate { 
      rename => [ "_BOOT_ID", "boot-id" ] 
      rename => [ "_CAP_EFFECTIVE", "cap-effective" ]
      rename => [ "_CMDLINE", "cmdline" ]
      rename => [ "_COMM", "comm" ]
      rename => [ "_EXE", "exe" ]
      rename => [ "_GID", "gid" ]
      rename => [ "_HOSTNAME", "hostname" ]
      rename => [ "_MACHINE_ID", "machine-id" ]
      rename => [ "_PID", "pid" ]
      rename => [ "_SELINUX_CONTEXT", "selinux-context" ]
      rename => [ "_SYSTEMD_CGROUP", "systemd-cgroup" ]
      rename => [ "_SYSTEMD_SLICE", "systemd-slice" ]
      rename => [ "_TRANSPORT", "transport" ]
      rename => [ "_UID", "uid" ]
      rename => [ "__CURSOR", "cursor" ]
      rename => [ "__MONOTONIC_TIMESTAMP", "monotonic-timestamp" ]
      rename => [ "__REALTIME_TIMESTAMP", "realtime-timestamp" ]
      rename => [ "_SOURCE_REALTIME_TIMESTAMP", "source-realtime-timestamp" ]
      rename => [ "MESSAGE", "message" ]
      rename => [ "_SYSTEMD_UNIT", "systemd-unit" ]
    }  
    
    if [systemd-unit] == "docker.service"{
      kv{ 
        source => "message"
      }
      date {
        "match" => [ "time", "ISO8601" ]
        target => "@timestamp"
      }
      mutate {
        remove_field => [ "time" ]
        rename => ["level","loglevel"]
      }
    } 
    else if [systemd-unit] == "kibana.service"{
      json{ 
        source => "message"
      }
      grok {
        match => ["realtime-timestamp", "(?<epoch>[0-9]{13})"] #trim timestamp to epoch/ms
      }
      date {
        "match" => [ "epoch", "UNIX_MS" ]
        target => "@timestamp"
      }
      mutate {
        remove_field => [ "epoch" ]
        remove_field => [ "realtime-timestamp" ]
        replace => [ "type", "systemd" ]
      }
    } 
    else if [systemd-unit] == "elasticsearch.service"{
      grok {
        match => [ "message", "\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{DATA:severity}%{SPACE}\]\[%{DATA:source}%{SPACE}\]%{SPACE}(?<message>(.|\r|\n)*)" ]
        overwrite => [ "message" ]
      }

      if "_grokparsefailure" not in [tags] {
        grok {
         match => [
            "message", "^\[%{DATA:node}\] %{SPACE}\[%{DATA:index}\]%{SPACE}(?<short_message>(.|\r|\n)*)",
            "message", "^\[%{DATA:node}\]%{SPACE}(?<short_message>(.|\r|\n)*)" 
            ]
          tag_on_failure => []
        }
  
        date { # use timestamp from the log
          "match" => [ "timestamp", "YYYY-MM-dd HH:mm:ss,SSS" ]
          target => "@timestamp"
        }
  
        mutate {
          remove_field => [ "timestamp" ]
          rename => ["severity","loglevel"]
        }
      }
    }
    mutate {
        remove_field => [ "monotonic-timestamp" ]
    }
  }
}


output {
  elasticsearch {
    hosts => "elasticsearch:9200"
  }
}
