input {
  tcp {
    type  => "systemd"
    port  => 5001
    codec => json_lines
    tags => ["systemd","coreos","journal"]
  }
  tcp {
    type => "fite-logs"
    port => 5010
    tags => ["windows","nxlog"]
  }
  tcp {
    type => "fite-iis-logs"
    port => 5011
    codec => json {
               charset => "CP1252"
             }
    tags => ["windows","iis","nxlog"]
  }
  tcp {
    type => "fite-webapps-logs"
    port => 5012
    tags => ["windows","nxlog"]
  }
  tcp {
    type => "fite-event-logs"
    port => 5013
    codec => json {
               charset => "CP1252"
             }
    tags => ["windows","event-log","nxlog"]
  }
}

filter {
  if [type] == "fite-event-logs" {
    date {
      match => ["EventTime", "yyyy-MM-dd HH:mm:ss"]
      timezone => "America/Chicago"
      target => "@timestamp"
    }
    mutate {
      remove_field => [ "keywords", 
                        "opcode", 
                        "processID", 
                        "RecordNumber", 
                        "SeverityValue", 
                        "SourceModuleName", 
                        "SourceModuleType", 
                        "Task", 
                        "ThreadID", 
                        "port", 
                        "EventID", 
                        "EventType", 
                        "Opcode", 
                        "OpcodeValue", 
                        "SourceName", 
                        "SubjectLogonId", 
                        "SubjectUserSid", 
                        "Version",
                        "Keywords",
                        "EventTime",
                        "TargetLogonId",
                        "TargetUserSid" ]
      rename => ["Severity", "log-level"]
      lowercase => ["log-level"]
    }
  }
  
  if [type] == "fite-iis-logs" {
      mutate {
        add_field => {
          "timestamp" => "%{date} %{time}"
        }
      }
    date {
      match => ["timestamp", "yyyy-MM-dd HH:mm:ss"]
      target => "@timestamp"
      remove_field => ["timestamp","date","time"]
    }
  }
  
  if [type] == "fite-webapps-logs" {
    grok{
      match => ["message","%{TIMESTAMP_ISO8601:ErrorTime} \[%{POSINT}\] %{LOGLEVEL} %{GREEDYDATA:module} - %{GREEDYDATA:exception}"]
    }
    date {
        match => [ "ErrorTime", "yyyy-MM-dd HH:mm:ss.SSS" ]
        target => "@timestamp"
    }
    mutate {
      add_field => {
        "log-level" => "info"
      }
    }
  }
  
  if [type] == "systemd" {
    mutate { 
      rename => [ "_BOOT_ID", "boot-id" ] 
      rename => [ "_CAP_EFFECTIVE", "cap-effective" ]
      rename => [ "_CMDLINE", "cmdline" ]
      rename => [ "_COMM", "comm" ]
      rename => [ "_EXE", "exe" ]
      rename => [ "_GID", "gid" ]
      rename => [ "_HOSTNAME", "hostname" ]
      rename => [ "_MACHINE_ID", "machine-id" ]
      rename => [ "_PID", "pid" ]
      rename => [ "_SELINUX_CONTEXT", "selinux-context" ]
      rename => [ "_SYSTEMD_CGROUP", "systemd-cgroup" ]
      rename => [ "_SYSTEMD_SLICE", "systemd-slice" ]
      rename => [ "_TRANSPORT", "transport" ]
      rename => [ "_UID", "uid" ]
      rename => [ "__CURSOR", "cursor" ]
      rename => [ "__MONOTONIC_TIMESTAMP", "monotonic-timestamp" ]
      rename => [ "__REALTIME_TIMESTAMP", "realtime-timestamp" ]
      rename => [ "_SOURCE_REALTIME_TIMESTAMP", "source-realtime-timestamp" ]
      rename => [ "MESSAGE", "message" ]
      rename => [ "_SYSTEMD_UNIT", "systemd-unit" ]
      remove_field => [ "PRIORITY",
                       "SYSLOG_FACILITY",
                       "SYSLOG_IDENTIFIER",
                       "uid", 
                       "transport", 
                       "gid",
                       "realtime-timestamp" ]
    }  
    
    if [systemd-unit] == "docker.service"{
      kv{ 
        source => "message"
      }
      date {
        "match" => [ "time", "ISO8601" ]
        target => "@timestamp"
      }
      mutate {
        remove_field => [ "time" ]
        rename => ["level","log-level"]
      }
    } 
    else if [systemd-unit] == "kibana.service"{
      #Drop all kibana messages. It is very chatty and doesn't yield useful information
      drop { }
#      json{ 
#        source => "message"
#      }
#      grok {
#        match => ["realtime-timestamp", "(?<epoch>[0-9]{13})"] #trim timestamp to epoch/ms
#      }
#      date {
#        "match" => [ "epoch", "UNIX_MS" ]
#        target => "@timestamp"
#      }
#      mutate {
#        remove_field => [ "epoch", "realtime-timestamp" ]
#        replace => [ "type", "systemd" ]
#      }
    } 
    else if [systemd-unit] == "elasticsearch.service"{
      grok {
        match => [ "message", "\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{DATA:severity}%{SPACE}\]\[%{DATA:source}%{SPACE}\]%{SPACE}(?<message>(.|\r|\n)*)" ]
        overwrite => [ "message" ]
      }

      if "_grokparsefailure" not in [tags] {
        grok {
         match => [
            "message", "^\[%{DATA:node}\] %{SPACE}\[%{DATA:index}\]%{SPACE}(?<short_message>(.|\r|\n)*)",
            "message", "^\[%{DATA:node}\]%{SPACE}(?<short_message>(.|\r|\n)*)" 
            ]
          tag_on_failure => []
        }
  
        date { # use timestamp from the log
          "match" => [ "timestamp", "YYYY-MM-dd HH:mm:ss,SSS" ]
          target => "@timestamp"
        }
  
        mutate {
          remove_field => [ "timestamp" ]
          rename => ["severity","log-level"]
        }
      }
    }
    mutate {
        remove_field => [ "monotonic-timestamp" ]
    }
  }
  mutate {
    lowercase => [ "log-level" ]
  }
}


output {
  elasticsearch {
    hosts => "elasticsearch:9200"
  }
}
