input {
  tcp {
    type => syslog
    port => 5000
  }
  udp {
    type => syslog
    port => 5000
  }
  tcp {
    port  => 5001
    codec => json_lines
    type  => "systemd"
  }
}

filter {
  if [type] == "systemd" {
    mutate { 
      rename => [ "_BOOT_ID", "boot-id" ] 
      rename => [ "_CAP_EFFECTIVE", "cap-effective" ]
      rename => [ "_CMDLINE", "cmdline" ]
      rename => [ "_COMM", "comm" ]
      rename => [ "_EXE", "exe" ]
      rename => [ "_GID", "gid" ]
      rename => [ "_HOSTNAME", "hostname" ]
      rename => [ "_MACHINE_ID", "machine-id" ]
      rename => [ "_PID", "pid" ]
      rename => [ "_SELINUX_CONTEXT", "selinux-context" ]
      rename => [ "_SYSTEMD_CGROUP", "systemd-cgroup" ]
      rename => [ "_SYSTEMD_SLICE", "systemd-slice" ]
      rename => [ "_TRANSPORT", "transport" ]
      rename => [ "_UID", "uid" ]
      rename => [ "__CURSOR", "cursor" ]
      rename => [ "__MONOTONIC_TIMESTAMP", "monotonic-timestamp" ]
      rename => [ "__REALTIME_TIMESTAMP", "realtime-timestamp" ]
      rename => [ "_SOURCE_REALTIME_TIMESTAMP", "source-realtime-timestamp" ]
      rename => [ "MESSAGE", "message" ]
      rename => [ "_SYSTEMD_UNIT", "systemd-unit" ]
    }  
    
    if [systemd-unit] == "docker.service"{
      kv{ 
        source => "message"
      }
      date {
        "match" => [ "time", "ISO8601" ]
        target => "@timestamp"
      }
      mutate {
        remove_field => [ "time" ]
        rename => ["level","loglevel"]
      }
    } 
    else if [systemd-unit] == "kibana.service"{
      json{ 
        source => "message"
      }
      grok {
        match => ["realtime-timestamp", "(?<epoch>[0-9]{13})"] #trim timestamp to epoch/ms
      }
      date {
        "match" => [ "epoch", "UNIX_MS" ]
        target => "@timestamp"
      }
      mutate {
        remove_field => [ "epoch" ]
        remove_field => [ "realtime-timestamp" ]
      }
    } 
    else if [systemd-unit] == "elasticsearch.service"{
      grok {
        match => [ "message", "\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{DATA:severity}%{SPACE}\]\[%{DATA:source}%{SPACE}\]%{SPACE}(?<message>(.|\r|\n)*)" ]
        overwrite => [ "message" ]
      }

      if "_grokparsefailure" not in [tags] {
        grok {
         match => [
            "message", "^\[%{DATA:node}\] %{SPACE}\[%{DATA:index}\]%{SPACE}(?<short_message>(.|\r|\n)*)",
            "message", "^\[%{DATA:node}\]%{SPACE}(?<short_message>(.|\r|\n)*)" 
            ]
          tag_on_failure => []
        }
  
        date { # use timestamp from the log
          "match" => [ "timestamp", "YYYY-MM-dd HH:mm:ss,SSS" ]
          target => "@timestamp"
        }
  
        mutate {
          remove_field => [ "timestamp" ]
          rename => ["severity","loglevel"]
        }
      }
    }
    mutate {
        remove_field => [ "monotonic-timestamp" ]
      }
  }
}


output {
  elasticsearch {
    hosts => "elasticsearch:9200"
  }
}
